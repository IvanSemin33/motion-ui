{"version":3,"file":"index.stories-304b6648.js","sources":["../../node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs","../../node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs","../../src/components/Select/index.tsx"],"sourcesContent":["import { invariant } from '../../utils/errors.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n","import { animationControls } from './animation-controls.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useIsomorphicLayoutEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n","import React, {\n  cloneElement,\n  Fragment,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\";\n\nimport classNames from \"classnames\";\nimport { AnimatePresence, motion, useAnimationControls } from \"framer-motion\";\nimport { isEmpty } from \"lodash\";\nimport { useClickAway } from \"react-use\";\n\nimport {\n  GoX as CancelIcon,\n  GoChevronDown as ExpandMoreIcon,\n} from \"react-icons/go\";\n\nimport styles from \"./index.module.scss\";\n\nimport InputBase, {\n  EInputBaseColors,\n  EInputBaseVariants,\n  InputBaseRef,\n} from \"../../core/InputBase\";\nimport wrapper from \"../../utils/wrapper\";\nimport Chip, { EChipColors, EChipSizes, EChipVariants } from \"../Chip\";\nimport CircularProgress from \"../CircularProgress\";\nimport List from \"../List\";\nimport ListItem, { IListItemProps } from \"../ListItem\";\nimport Popper, { EPopperPosition } from \"../Popper\";\n\nexport const ESelectColors = EInputBaseColors;\nexport type ESelectColors = EInputBaseColors;\n\nexport const ESelectVariants = EInputBaseVariants;\nexport type ESelectVariants = EInputBaseVariants;\n\nexport enum ESelectMultipleVariant {\n  DEFAULT = \"default\",\n  CHIP = \"chip\",\n}\n\nexport type TValue = string | number;\n\nexport type TOption = {\n  label: React.ReactNode;\n  value: TValue;\n};\n\nexport interface ISelectOwnProps\n  extends Omit<\n    React.InputHTMLAttributes<HTMLInputElement>,\n    \"color\" | \"onChange\" | \"value\"\n  > {\n  className?: string;\n  color?: ESelectColors;\n  disabled?: boolean;\n  emptyListText?: string;\n  helperText?: string;\n  isFetching?: boolean;\n  isLoading?: boolean;\n  label?: string;\n  multiple?: boolean;\n  multiplePlaceholder?: string;\n  multipleVariant?: ESelectMultipleVariant;\n  onChange?: (value?: TValue | TValue[]) => void;\n  onClear?: () => void;\n  onSearchChange?: (value: string) => void;\n  options: TOption[];\n  placeholder?: string;\n  popperClassName?: string;\n  renderValue?: (value: TOption | TOption[]) => string;\n  searchValue?: string;\n  value?: TValue | TValue[];\n  variant?: ESelectVariants;\n}\n\nexport type TSelectRef = HTMLDivElement;\n\nconst Select = wrapper<TSelectRef, ISelectOwnProps>(\n  (\n    {\n      className,\n      color,\n      disabled,\n      emptyListText,\n      helperText,\n      isFetching,\n      isLoading,\n      label,\n      multiple,\n      multiplePlaceholder,\n      multipleVariant,\n      onChange,\n      onClear,\n      onSearchChange,\n      options,\n      placeholder,\n      popperClassName,\n      renderValue,\n      searchValue,\n      value,\n      variant,\n      ...inputProps\n    },\n    ref\n  ) => {\n    const isMultiple = multiple && Array.isArray(value);\n\n    const containerRef = useRef<InputBaseRef>(null);\n    const inputRef = useRef<HTMLInputElement>(null);\n    const popperRef = useRef<HTMLDivElement>(null);\n    const initialOptions = useRef<typeof options>(options);\n\n    const [isFocused, setIsFocused] = useState<boolean>(false);\n    const [isOpen, setIsOpen] = useState<boolean>(false);\n    const [count, setCount] = useState(\n      isMultiple ? (value as TValue[])?.length : 0\n    );\n    const [currentOption, setCurrentOption] = useState<\n      TOption | TOption[] | undefined\n    >(undefined);\n\n    const countControls = useAnimationControls();\n    const isSearchable = !!onSearchChange;\n    const isClearable =\n      (isMultiple ? (currentOption as TOption[])?.length : currentOption) &&\n      onClear &&\n      !disabled;\n\n    useImperativeHandle(ref, () => containerRef.current as TSelectRef);\n\n    useEffect(() => {\n      if (isMultiple) {\n        if (isSearchable) {\n          const newCurrentOptions = initialOptions.current.filter((option) =>\n            (value as TValue[])?.includes(option.value)\n          );\n\n          if (newCurrentOptions.length > 0) {\n            setCurrentOption(newCurrentOptions);\n          }\n        } else {\n          const newCurrentOptions = options.filter((option) =>\n            (value as TValue[])?.includes(option.value)\n          );\n          setCurrentOption(newCurrentOptions);\n        }\n      } else {\n        if (isSearchable) {\n          const newCurrentOption = options.find(\n            (option) => option.value === value\n          );\n\n          if (newCurrentOption) {\n            setCurrentOption(newCurrentOption);\n          }\n        } else {\n          setCurrentOption(options.find((o) => o.value === value));\n        }\n      }\n    }, [isMultiple, options, value, isSearchable]);\n\n    const inputValue: string = (() => {\n      if (typeof searchValue === \"string\" && isEmpty(currentOption)) {\n        return searchValue || \"\";\n      } else if (currentOption) {\n        return renderValue\n          ? renderValue(currentOption)\n          : (currentOption as TOption)?.label?.toString() || \"\";\n      } else {\n        return \"\";\n      }\n    })();\n\n    const setIsPopperOpen = useCallback(\n      (isOpen: boolean) => {\n        if (disabled) {\n          setIsOpen(false);\n        } else {\n          setIsOpen(isOpen);\n        }\n      },\n      [disabled]\n    );\n\n    useEffect(() => {\n      if (disabled) {\n        setIsPopperOpen(false);\n      }\n    }, [disabled, setIsPopperOpen]);\n\n    useEffect(() => {\n      if (isOpen) {\n        setIsFocused(true);\n        inputRef.current?.focus();\n      } else {\n        setIsFocused(false);\n        inputRef.current?.blur();\n      }\n    }, [isOpen, setIsFocused]);\n\n    useClickAway(popperRef, (e) => {\n      if (!containerRef.current?.contains(e.target as Node)) {\n        setIsPopperOpen(false);\n      }\n    });\n\n    const onClickClear = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n      event.stopPropagation();\n      setCurrentOption(undefined);\n      onClear?.();\n    };\n\n    const onClickOption = (clickedOption: TOption) => (e: React.MouseEvent) => {\n      if (isMultiple) {\n        e.stopPropagation();\n\n        const currentValues = (currentOption as TOption[])?.map(\n          ({ value }) => value\n        );\n        const isSelected = currentValues?.some(\n          (v) => v === clickedOption.value\n        );\n\n        const newValue = isSelected\n          ? currentValues?.filter((v) => v !== clickedOption.value)\n          : [...currentValues, clickedOption.value];\n\n        onChange?.(newValue);\n        onSearchChange?.(\"\");\n        inputRef.current?.focus();\n      } else {\n        onChange?.(clickedOption.value);\n        onSearchChange?.(\"\");\n        setIsPopperOpen(false);\n      }\n    };\n\n    const renderActions = () => {\n      return (\n        <motion.span\n          animate={isClearable ? \"selected\" : \"empty\"}\n          className={styles.actions}\n          initial=\"empty\"\n          variants={{\n            selected: {\n              marginRight: \"0px\",\n              transition: { duration: 0.2, delay: 0 },\n            },\n            empty: {\n              marginRight: \"-24px\",\n              transition: { duration: 0.2, delay: 0 },\n            },\n          }}\n        >\n          {isLoading && <CircularProgress className={styles.loader} />}\n          <motion.span\n            animate={isOpen ? \"open\" : \"closed\"}\n            className={styles.expandIcon}\n            variants={{\n              open: {\n                rotate: 180,\n              },\n              closed: {\n                rotate: 0,\n              },\n            }}\n          >\n            <ExpandMoreIcon size={20} />\n          </motion.span>\n          <motion.span\n            className={styles.clearIcon}\n            variants={{\n              selected: {\n                visibility: \"visible\",\n                opacity: 1,\n                rotate: -90,\n                transition: { duration: 0.1, delay: 0.1 },\n              },\n              empty: {\n                visibility: \"hidden\",\n                opacity: 0,\n                rotate: 0,\n                transition: { duration: 0.1, delay: 0 },\n              },\n            }}\n          >\n            <CancelIcon size={20} onClick={onClickClear} />\n          </motion.span>\n        </motion.span>\n      );\n    };\n\n    const renderOption = (option: TOption) => {\n      const isSelected = isMultiple\n        ? (currentOption as TOption[])?.some(\n            (selectedValue) => selectedValue.value === option.value\n          )\n        : (currentOption as TOption)?.value === option.value;\n\n      const listItemProps: IListItemProps = {\n        onClick: onClickOption(option),\n        selected: isSelected,\n      };\n\n      if (React.isValidElement(option.label)) {\n        return cloneElement(option.label as JSX.Element, {\n          ...listItemProps,\n        });\n      } else {\n        return (\n          <ListItem key={`${option.label}_${option.value}`} {...listItemProps}>\n            {option.label}\n          </ListItem>\n        );\n      }\n    };\n\n    const onInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n      if (isMultiple) {\n        onSearchChange?.(event.target.value);\n      } else {\n        onSearchChange?.(event.target.value);\n        setCurrentOption(undefined);\n        onChange?.(undefined);\n      }\n    };\n\n    const renderEmptyList = () => (\n      <ListItem disabled className={styles.emptyListItem}>\n        {emptyListText}\n      </ListItem>\n    );\n\n    const renderChips = () =>\n      (currentOption as TOption[])?.map((option) => (\n        <Chip\n          key={`chip_${option.label}_${option.value}`}\n          label={option.label}\n          onDelete={onClickOption(option)}\n          variant={EChipVariants.FILLED}\n          color={EChipColors.PRIMARY}\n          size={EChipSizes.SMALL}\n          initial={{ scale: 0 }}\n          animate={{ scale: 1 }}\n          exit={{ scale: 0 }}\n        />\n      ));\n\n    const animateCount = useCallback(\n      async (direction: -1 | 1) => {\n        await countControls.start({ y: 0, opacity: 1 });\n        await countControls.start({ y: direction * -10, opacity: 0 });\n        await countControls.start({ y: direction * 10, opacity: 0 });\n        return await countControls.start({ y: 0, opacity: 1 });\n      },\n      [countControls]\n    );\n\n    useEffect(() => {\n      if (isMultiple) {\n        const length = (currentOption as TOption[])?.length || 0;\n\n        if (length > count) {\n          animateCount(1);\n          setTimeout(() => {\n            setCount(length || 0);\n          }, 300);\n        } else if (length < count) {\n          animateCount(-1);\n          setTimeout(() => {\n            setCount(length || 0);\n          }, 300);\n        }\n      }\n    }, [currentOption, isMultiple, count, animateCount]);\n\n    const renderCount = () => {\n      return (\n        <motion.span\n          animate={countControls}\n          transition={{\n            duration: 0.1,\n          }}\n        >\n          {count}\n        </motion.span>\n      );\n    };\n\n    const renderChipPlaceholder = () => (\n      <Chip\n        className={styles.chipPlaceholder}\n        label={\n          <Fragment>\n            <span className={styles.multiplePlaceholder}>\n              {multiplePlaceholder}\n            </span>\n            {renderCount()}\n          </Fragment>\n        }\n        variant={EChipVariants.FILLED}\n        color={EChipColors.SECONDARY}\n        size={EChipSizes.SMALL}\n      />\n    );\n\n    const renderInput = () => {\n      const isValueEmpty = isMultiple\n        ? (currentOption as TOption[])?.length === 0\n        : !currentOption;\n\n      return isSearchable || (isValueEmpty && placeholder) || currentOption ? (\n        <input\n          ref={inputRef}\n          className={classNames(styles.input, disabled && styles.disabled)}\n          disabled={!(isSearchable && !disabled)}\n          value={inputValue}\n          onChange={onInputChange}\n          placeholder={isValueEmpty || isSearchable ? placeholder : \"\"}\n          {...inputProps}\n        />\n      ) : null;\n    };\n\n    return (\n      <Fragment>\n        <InputBase\n          ref={containerRef}\n          variant={variant}\n          disabled={disabled}\n          helperText={helperText}\n          label={label}\n          color={color}\n          isFetching={isFetching}\n          isFocused={isFocused}\n          // THINK: maybe compare with e.target\n          onClick={() => setIsPopperOpen(!isOpen)}\n          className={classNames(styles.container, className)}\n        >\n          {isMultiple ? (\n            <div className={styles.multiple}>\n              <AnimatePresence>\n                {multipleVariant === ESelectMultipleVariant.CHIP &&\n                  renderChips()}\n              </AnimatePresence>\n              {multipleVariant === ESelectMultipleVariant.DEFAULT &&\n                renderChipPlaceholder()}\n              {renderInput()}\n            </div>\n          ) : (\n            renderInput()\n          )}\n          {renderActions()}\n        </InputBase>\n        <Popper\n          ref={popperRef}\n          open={isOpen}\n          anchorEl={containerRef.current}\n          position={EPopperPosition.BOTTOM}\n          className={classNames(styles.popper, popperClassName)}\n          fullWidth\n        >\n          <List>\n            {options?.length ? options.map(renderOption) : renderEmptyList()}\n          </List>\n        </Popper>\n      </Fragment>\n    );\n  }\n);\n\nSelect.defaultProps = {\n  color: ESelectColors.PRIMARY,\n  disabled: false,\n  variant: ESelectVariants.FILLED,\n  emptyListText: \"No options\",\n  multiplePlaceholder: \"Selected:\",\n};\n\nexport interface ISelectProps extends React.ComponentProps<typeof Select> {}\n\nexport default Select;\n"],"names":["stopAnimation","visualElement","value","animationControls","subscribers","controls","definition","transitionOverride","animations","animateVisualElement","setValues","useAnimationControls","useConstant","useIsomorphicLayoutEffect","ESelectColors","EInputBaseColors","ESelectVariants","EInputBaseVariants","ESelectMultipleVariant","ESelectMultipleVariant2","Select","wrapper","className","color","disabled","emptyListText","helperText","isFetching","isLoading","label","multiple","multiplePlaceholder","multipleVariant","onChange","onClear","onSearchChange","options","placeholder","popperClassName","renderValue","searchValue","variant","inputProps","ref","isMultiple","containerRef","useRef","inputRef","popperRef","initialOptions","isFocused","setIsFocused","useState","isOpen","setIsOpen","count","setCount","currentOption","setCurrentOption","countControls","isSearchable","isClearable","useImperativeHandle","useEffect","newCurrentOptions","option","newCurrentOption","o","inputValue","isEmpty","_a","setIsPopperOpen","useCallback","isOpen2","_b","useClickAway","onClickClear","event","onClickOption","clickedOption","e","currentValues","value2","newValue","v","renderActions","jsxs","motion","styles","jsx","CircularProgress","ExpandMoreIcon","CancelIcon","renderOption","isSelected","selectedValue","listItemProps","React","cloneElement","ListItem","onInputChange","renderEmptyList","renderChips","Chip","EChipVariants","EChipColors","EChipSizes","animateCount","direction","length","renderCount","renderChipPlaceholder","Fragment","renderInput","isValueEmpty","classNames","InputBase","AnimatePresence","Popper","EPopperPosition","List","Select$1"],"mappings":"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","x_google_ignoreList":[0,1]}