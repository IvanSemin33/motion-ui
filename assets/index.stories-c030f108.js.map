{"version":3,"file":"index.stories-c030f108.js","sources":["../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs","../../node_modules/framer-motion/dist/es/value/use-motion-template.mjs","../../node_modules/framer-motion/dist/es/value/use-spring.mjs","../../src/components/LinearProgress/index.tsx"],"sourcesContent":["import { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","import { useMotionValue } from './use-motion-value.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { cancelFrame, frame } from '../frameloop/frame.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.update(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n","import { useCombineMotionValues } from './use-combine-values.mjs';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments, ...values) {\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    const numFragments = fragments.length;\n    function buildValue() {\n        let output = ``;\n        for (let i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            const value = values[i];\n            if (value) {\n                output += isMotionValue(value) ? value.get() : value;\n            }\n        }\n        return output;\n    }\n    return useCombineMotionValues(values.filter(isMotionValue), buildValue);\n}\n\nexport { useMotionTemplate };\n","import { useContext, useRef, useInsertionEffect } from 'react';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { animateValue } from '../animation/animators/js/index.mjs';\nimport { millisecondsToSeconds } from '../utils/time-conversion.mjs';\nimport { frameData } from '../frameloop/frame.mjs';\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config = {}) {\n    const { isStatic } = useContext(MotionConfigContext);\n    const activeSpringAnimation = useRef(null);\n    const value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    const stopAnimation = () => {\n        if (activeSpringAnimation.current) {\n            activeSpringAnimation.current.stop();\n        }\n    };\n    useInsertionEffect(() => {\n        return value.attach((v, set) => {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            stopAnimation();\n            activeSpringAnimation.current = animateValue({\n                keyframes: [value.get(), v],\n                velocity: value.getVelocity(),\n                type: \"spring\",\n                restDelta: 0.001,\n                restSpeed: 0.01,\n                ...config,\n                onUpdate: set,\n            });\n            /**\n             * If we're between frames, resync the animation to the frameloop.\n             */\n            if (!frameData.isProcessing) {\n                const delta = performance.now() - frameData.timestamp;\n                if (delta < 30) {\n                    activeSpringAnimation.current.time =\n                        millisecondsToSeconds(delta);\n                }\n            }\n            return value.get();\n        }, stopAnimation);\n    }, [JSON.stringify(config)]);\n    useIsomorphicLayoutEffect(() => {\n        if (isMotionValue(source)) {\n            return source.on(\"change\", (v) => value.set(parseFloat(v)));\n        }\n    }, [value]);\n    return value;\n}\n\nexport { useSpring };\n","import { useEffect } from 'react'\n\nimport classNames from 'classnames'\nimport {\n  HTMLMotionProps,\n  motion,\n  useMotionTemplate,\n  useMotionValue,\n  useSpring,\n} from 'framer-motion'\n\nimport styles from './index.module.scss'\n\nimport wrapper from '../../utils/wrapper'\n\nexport enum ELinearProgressColor {\n  PRIMARY = 'primary',\n  ERROR = 'error',\n  SUCCESS = 'success',\n}\n\nexport enum ELinearProgressLabelPosition {\n  TOP = 'top',\n  RIGHT = 'right',\n}\n\nexport enum ELinearProgressSize {\n  SMALL = 'small',\n  MEDIUM = 'medium',\n}\n\nexport interface ILinearProgressOwnProps extends HTMLMotionProps<'div'> {\n  color?: ELinearProgressColor\n  isFetching?: boolean\n  labelPosition?: ELinearProgressLabelPosition\n  renderLabel?: () => string\n  size?: ELinearProgressSize\n  value: number\n}\n\nexport type TLinearProgressRef = HTMLDivElement\n\nconst LinearProgress = wrapper<TLinearProgressRef, ILinearProgressOwnProps>(\n  ({ color, isFetching, labelPosition, size, value, renderLabel, ...containerProps }, ref) => {\n    const x = useMotionValue(0)\n    const progressX = useSpring(x, { stiffness: 100, damping: 30, restDelta: 0.001 })\n\n    const transformProgress = useMotionTemplate`translateX(${progressX}%)`\n\n    useEffect(() => {\n      x.set(value)\n    }, [value])\n\n    return (\n      <motion.div\n        ref={ref}\n        className={classNames(\n          styles.container,\n          color && styles[color],\n          size && styles[size],\n          isFetching && styles.isFetching,\n          labelPosition && styles[labelPosition]\n        )}\n        {...containerProps}\n      >\n        <div className={classNames(styles.label, renderLabel && styles.customLabel)}>\n          {renderLabel ? renderLabel() : `${value}%`}\n        </div>\n        <div className={styles.progressWrapper}>\n          <motion.div\n            className={styles.progress}\n            style={{\n              transform: transformProgress,\n            }}\n          />\n        </div>\n      </motion.div>\n    )\n  }\n)\n\nLinearProgress.defaultProps = {\n  color: ELinearProgressColor.PRIMARY,\n  labelPosition: ELinearProgressLabelPosition.TOP,\n  size: ELinearProgressSize.MEDIUM,\n}\n\nexport interface ILinearProgressProps extends React.ComponentProps<typeof LinearProgress> {}\n\nexport default LinearProgress\n"],"names":["useMotionValue","initial","value","useConstant","motionValue","isStatic","useContext","MotionConfigContext","setLatest","useState","useEffect","useCombineMotionValues","values","combineValues","updateValue","useIsomorphicLayoutEffect","scheduleUpdate","frame","subscriptions","v","unsubscribe","cancelFrame","useMotionTemplate","fragments","numFragments","buildValue","output","i","isMotionValue","useSpring","source","config","activeSpringAnimation","useRef","stopAnimation","useInsertionEffect","set","animateValue","frameData","delta","millisecondsToSeconds","ELinearProgressColor","ELinearProgressColor2","ELinearProgressLabelPosition","ELinearProgressLabelPosition2","ELinearProgressSize","ELinearProgressSize2","LinearProgress","wrapper","color","isFetching","labelPosition","size","renderLabel","containerProps","ref","x","progressX","transformProgress","jsxs","motion","classNames","styles","jsx"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}